>2024/3/25 一

感觉这题理解还是有问题的，mark一下
(第一次觉得自己能造hack数据但……)

## 状压dp2

# [蓝桥杯 2019 省 A] 糖果

>## 题目描述

>糖果店的老板一共有 $M$ 种口味的糖果出售。为了方便描述，我们将 $M$ 种口味编号 $1$ ∼ $M$。

>小明希望能品尝到所有口味的糖果。遗憾的是老板并不单独出售糖果，而是 $K$ 颗一包整包出售。

>幸好糖果包装上注明了其中 $K$ 颗糖果的口味，所以小明可以在买之前就知道每包内的糖果口味。

>给定 $N$ 包糖果，请你计算小明最少买几包，就可以品尝到所有口味的糖果。

## 提示

对于 $30\%$ 的评测用例，$1 \le N \le 20$。

对于所有评测样例，$1 \le N \le 100$，$1 \le M \le 20$，$1 \le K \le 20$，$1 \le T_i \le M$。

蓝桥杯 2019 年省赛 A 组 I 题。

P8687 [蓝桥杯 2019 省 A] 糖果

看到数据范围的时候以为暴搜（实际上暴搜还是会超的$2^N$），没想到直接状压……
而且偷看了状压思路之后居然还又t又wa，$2^n$必t啊摆脱，肯定不能从选哪几包糖果的方案做状压了！

```c++
//这是错的这是错的，而且显然对二进制不熟练啊喂！！）
	LL num = pow(2, n);//对n包糖果的选择有2^n种情况
	for(LL i = 1; i < num; i++){//一包都不选的就不用尝试了
		LL cnt = 0;
		bool flag[M] = {0};//标记这种选择方式选到了哪些糖果
		for(int j = 0; j < n; j++){//遍历n包糖果找出当前选中的
			if(1 & (i >> j)){//如果被选中，那这包糖果里的每种糖被选中
				for(int l = 0; l < k; l++){
					flag[a[j][l]] = 1;
				}
				cnt += 1;//记录选中的包数
			}
		}
		bool judge = 0;
		for(int i = 1; i <= m; i++){
			if(!flag[i]){//如果有糖没有选中，方案不合法
				judge = 1;
				break;
			}

```

然后观察数据范围可得（？？？？？）这题要从得到糖果的组合入手！记录最小方案数来dp，时间复杂度优化到$O(N×2^M)$。（M大时可以用IDA）
同时，既然只需要得到选某几包之后得到的糖果种类的方案，那么提前状压好每包糖果里含有的糖果种类就可以了。

注意不是每个dp[i]\(每种糖果搭配)都是有被更新选糖果包数的，只有恰好这种方案可以由选某几包糖得到的时候才会有值，但我们只关心所有糖果种类都选中这一种方案，所以只输出最后所有糖果种类都选中时的dp值就可以。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 1<<21;//存的是二进制
int a[N], dp[N];
int n, m, k;

int main(){
	memset(dp, 0x3f, sizeof(dp));//取最小值别忘记初始化
	dp[0] = 0;
	
	scanf("%d%d%d", &n, &m, &k);
	for(int i = 0; i < n; i++){
		for(int j = 0; j < k; j++){
			int x;
			cin >> x;
			a[i] |= 1 << (x-1);//记录这包里有哪些糖果,注意一包可能有多种同一口味
		}
	}

	for(int j = 0; j <= n; j++){//向当前的dp组合里加糖果	
		for(int i = 0; i < 1 << m; i++){
			if(dp[i] > 100) continue;//很暴力的排除重复选的情况：只要超过100必有重复，那就不要了（实际上真的记录然后保证每步都不重复是很难的，这里直接等到最后再排除）
				dp[i|a[j]] = min(dp[i] + 1, dp[i|a[j]]);//注意这里按位或的用法，表示有可能重复的加入
		}
	}
	if(dp[(1<<m)- 1] < 110) cout << dp[(1<<m)- 1];
	else puts("-1");
	return 0;
}
```
